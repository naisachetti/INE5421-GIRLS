A ::= & | { STATELIST } | break ; | ; | print EXPRESSION ; | read ident AUX10'1 ; | for ( ident AUX10'1 = AUX3 ; EXPRESSION ; ident AUX10'1 = AUX3 ) AUX1 | ident A'1 | return RETURNSTAT ; | TYPE ident VARDECL ; | def ident ( A'2 | if ( EXPRESSION ) AUX1 A'3
A'1 ::= AUX10'1 = AUX3 ; | ( FUNCCALL ;
A'2 ::= ) { STATELIST } A'4 | TYPE ident AUX10'1 AUX25 ) { STATELIST } A'4
A'3 ::= & | else AUX1
A'4 ::= & | def ident ( A'2
ARRAYCONTENTS ::= & | , = EXPRESSION ARRAYCONTENTS
AUX1 ::= { STATELIST } | break ; | ; | print EXPRESSION ; | return AUX1'1 | read ident AUX10'1 ; | for ( ident AUX10'1 = AUX3 ; EXPRESSION ; ident AUX10'1 = AUX3 ) AUX1 | ident AUX1'2 | TYPE ident VARDECL ; | if ( EXPRESSION ) AUX1 A'3
AUX1'1 ::= ; | AUX14 ;
AUX1'2 ::= AUX10'1 = AUX3 ; | ( AUX1'3
AUX1'3 ::= ) ; | ident AUX13 ) ;
AUX10 ::= string_constant | float_constant | null | ( NUMEXPRESSION ) | int_constant | ident AUX10'1 | [ = EXPRESSION ARRAYCONTENTS ]
AUX10'1 ::= & | [ AUX17
AUX13 ::= & | , AUX13'1
AUX13'1 ::= & | ident AUX13
AUX14 ::= string_constant AUX14'1 | float_constant AUX14'1 | null AUX14'1 | int_constant AUX14'1 | SIGNAL AUX10 AUX14'1 | ( NUMEXPRESSION ) AUX14'1 | [ = EXPRESSION ARRAYCONTENTS ] AUX14'1 | ident AUX14'2
AUX14'1 ::= & | , RETURNSTAT | OPERATION UNARYEXPR TERM'1 AUX14'3 | SIGNAL TERM NUMEXPRESSION'3 AUX14'4
AUX14'2 ::= & | [ AUX17 AUX14'1 | , RETURNSTAT | OPERATION UNARYEXPR TERM'1 AUX14'3 | SIGNAL TERM NUMEXPRESSION'3 AUX14'4
AUX14'3 ::= & | , RETURNSTAT | SIGNAL TERM NUMEXPRESSION'3 AUX14'4
AUX14'4 ::= & | , RETURNSTAT
AUX17 ::= ] AUX10'1 | NUMEXPRESSION ] AUX10'1
AUX20 ::= & | [ NUMEXPRESSION ] AUX20
AUX25 ::= & | , AUX25'1
AUX25'1 ::= & | TYPE ident AUX10'1 AUX25
AUX3 ::= string_constant AUX3'1 | float_constant AUX3'1 | null AUX3'1 | int_constant AUX3'1 | SIGNAL AUX10 AUX3'1 | ( NUMEXPRESSION ) AUX3'1 | [ = EXPRESSION ARRAYCONTENTS ] AUX3'1 | new TYPE [ NUMEXPRESSION ] AUX20 | ident AUX3'2
AUX3'1 ::= & | COMPARE NUMEXPRESSION | OPERATION UNARYEXPR TERM'1 AUX3'3 | SIGNAL TERM NUMEXPRESSION'3 AUX3'4
AUX3'2 ::= & | COMPARE NUMEXPRESSION | ( FUNCCALL | [ AUX17 AUX3'1 | OPERATION UNARYEXPR TERM'1 AUX3'3 | SIGNAL TERM NUMEXPRESSION'3 AUX3'4
AUX3'3 ::= & | COMPARE NUMEXPRESSION | SIGNAL TERM NUMEXPRESSION'3 AUX3'4
AUX3'4 ::= & | COMPARE NUMEXPRESSION
COMPARE ::= == | != | <= | >= | < | >
EXPRESSION ::= string_constant AUX3'1 | float_constant AUX3'1 | null AUX3'1 | int_constant AUX3'1 | SIGNAL AUX10 AUX3'1 | ( NUMEXPRESSION ) AUX3'1 | [ = EXPRESSION ARRAYCONTENTS ] AUX3'1 | ident EXPRESSION'1
EXPRESSION'1 ::= & | COMPARE NUMEXPRESSION | [ AUX17 AUX3'1 | OPERATION UNARYEXPR TERM'1 AUX3'3 | SIGNAL TERM NUMEXPRESSION'3 AUX3'4
FUNCCALL ::= ) | ident AUX13 )
NUMEXPRESSION ::= string_constant NUMEXPRESSION'1 | float_constant NUMEXPRESSION'1 | null NUMEXPRESSION'1 | int_constant NUMEXPRESSION'1 | SIGNAL AUX10 NUMEXPRESSION'1 | ( NUMEXPRESSION ) NUMEXPRESSION'1 | [ = EXPRESSION ARRAYCONTENTS ] NUMEXPRESSION'1 | ident NUMEXPRESSION'2
NUMEXPRESSION'1 ::= & | OPERATION UNARYEXPR TERM'1 NUMEXPRESSION'3 | SIGNAL TERM NUMEXPRESSION'3
NUMEXPRESSION'2 ::= & | [ AUX17 NUMEXPRESSION'1 | OPERATION UNARYEXPR TERM'1 NUMEXPRESSION'3 | SIGNAL TERM NUMEXPRESSION'3
NUMEXPRESSION'3 ::= & | SIGNAL TERM NUMEXPRESSION'3
OPERATION ::= * | % | /
RETURNSTAT ::= & | string_constant AUX14'1 | float_constant AUX14'1 | null AUX14'1 | int_constant AUX14'1 | SIGNAL AUX10 AUX14'1 | ( NUMEXPRESSION ) AUX14'1 | [ = EXPRESSION ARRAYCONTENTS ] AUX14'1 | ident AUX14'2
SIGNAL ::= - | +
STATELIST ::= return STATELIST'2 | ident STATELIST'1 | ; STATELIST'3 | break ; STATELIST'3 | print EXPRESSION ; STATELIST'3 | { STATELIST } STATELIST'3 | read ident AUX10'1 ; STATELIST'3 | for ( ident AUX10'1 = AUX3 ; EXPRESSION ; ident AUX10'1 = AUX3 ) AUX1 STATELIST'3 | if ( EXPRESSION ) AUX1 STATELIST'5 | TYPE ident VARDECL ; STATELIST'3
STATELIST'1 ::= AUX10'1 = AUX3 ; STATELIST'3 | ( STATELIST'4
STATELIST'2 ::= ; STATELIST'3 | AUX14 ; STATELIST'3
STATELIST'3 ::= & | return STATELIST'2 | ident STATELIST'1 | ; STATELIST'3 | break ; STATELIST'3 | print EXPRESSION ; STATELIST'3 | { STATELIST } STATELIST'3 | read ident AUX10'1 ; STATELIST'3 | for ( ident AUX10'1 = AUX3 ; EXPRESSION ; ident AUX10'1 = AUX3 ) AUX1 STATELIST'3 | if ( EXPRESSION ) AUX1 STATELIST'5 | TYPE ident VARDECL ; STATELIST'3
STATELIST'4 ::= ) ; STATELIST'3 | ident AUX13 ) ; STATELIST'3
STATELIST'5 ::= & | else AUX1 STATELIST'3 | return STATELIST'2 | ident STATELIST'1 | ; STATELIST'3 | break ; STATELIST'3 | print EXPRESSION ; STATELIST'3 | { STATELIST } STATELIST'3 | read ident AUX10'1 ; STATELIST'3 | for ( ident AUX10'1 = AUX3 ; EXPRESSION ; ident AUX10'1 = AUX3 ) AUX1 STATELIST'3 | if ( EXPRESSION ) AUX1 STATELIST'5 | TYPE ident VARDECL ; STATELIST'3
TERM ::= string_constant TERM'1 | float_constant TERM'1 | null TERM'1 | int_constant TERM'1 | SIGNAL AUX10 TERM'1 | ( NUMEXPRESSION ) TERM'1 | [ = EXPRESSION ARRAYCONTENTS ] TERM'1 | ident TERM'2
TERM'1 ::= & | OPERATION UNARYEXPR TERM'1
TERM'2 ::= & | OPERATION UNARYEXPR TERM'1 | [ AUX17 TERM'1
TYPE ::= int | float | string
UNARYEXPR ::= string_constant | float_constant | null | ( NUMEXPRESSION ) | int_constant | SIGNAL AUX10 | ident AUX10'1 | [ = EXPRESSION ARRAYCONTENTS ]
VARDECL ::= & | [ int_constant ] VARDECL
